---
title: "Extract BUSCO from HybPiper"
author: "Jeremias Ivan"
date: "`r format(Sys.time(), '%d %B %Y, %H:%M%p')`"

output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true

params:
  # general
  codedir: "~/EucsPhylogenomics/codes/busco"
  outdir: "~/simulation"
  thread: 10
  redo: FALSE

  # input directory
  fn_target_dna: ""
  dir_hybpiper_output: ""

  fn_quibl_metadata: "~/EucsPhylogenomics/files/target_species.tsv"

  # executable
  exe_cialign: ""
  exe_mafft: ""
  exe_iqtree2: ""
  exe_astral: ""
  exe_quibl: ""
---

## Load required libraries and functions
```{r}
source(paste0(params$codedir, "/functions.R"))

library(data.table)
library(doSNOW)
library(tidyverse)
```

```{r, include=FALSE}
# install.packages("ape")
# install.packages("Biostrings")
# install.packages("log4r")

# store initial system time
sys_tic <- Sys.time()

# create outdir
currentdir <- paste0(params$outdir, "/")
if (!dir.exists(currentdir)) {
  dir.create(currentdir, recursive = T)
}

# create log file
fn_log <- paste0(params$outdir, "/extract_hybpiper.log")
log_appender <- log4r::file_appender(fn_log, append = TRUE, layout = log4r::default_log_layout())
fn_logger <- log4r::logger(threshold = "INFO", appenders = log_appender)
if (params$redo || !file.exists(fn_log)) {
  unlink(fn_log)
  write.table(c("EucsPhylogenomics",
                "Developed by Jeremias Ivan"),
              file=fn_log, quote=F, row.names=F, col.names=F)
}

knitr::opts_knit$set(root.dir = currentdir)
```

```{r references}
# open target DNA
seq <- Biostrings::readDNAStringSet(params$fn_target_dna)
names(seq) <- gsub(" ", "", names(seq))
names(seq) <- gsub("_N/A", "", names(seq))

ls_target_busco <- names(seq)
ls_target_busco <- unique(sapply(ls_target_busco, function(x) { unlist(strsplit(x, "-"))[2] }))

log4r::info(fn_logger, paste0("Number of BUSCO: ", length(ls_target_busco)))

# iterate over BUSCO
for (busco in ls_target_busco) {
    # output directory
    output_busco <- paste0(params$outdir, "/", busco, "/")
    if (!dir.exists(output_busco)) {
        dir.create(output_busco, recursive=T)
    }

    # extract BUSCO headers
    idx <- grepl(paste0("-", busco, "$"), names(seq))
    busco_seq <- seq[idx]

    # update BUSCO headers
    names(busco_seq) <- sapply(names(busco_seq), function(x) {
        header <- gsub(paste0("-", busco, "$"), "", x)
    })

    # output file
    fn_out_fa <- paste0(output_busco, busco, ".fa")
    Biostrings::writeXStringSet(busco_seq, filepath=fn_out_fa)
}
```

```{r alignments}
# extract list of species
ls_species <- list.dirs(params$dir_hybpiper_output, recursive=F, full.names=F)

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over species
for (sp in ls_species) {
    # HybPiper output directory
    outdir_sp <- paste0(params$dir_hybpiper_output, "/", sp, "/")

    # extract list of BUSCO
    ls_busco <- list.dirs(outdir_sp, recursive=F, full.names=F)

    # read file containing paralogs
    fn_paralogs <- paste0(outdir_sp, sp, "_genes_with_long_paralog_warnings.txt")
    if (!file.exists(fn_paralogs)) {
        log4r::warn(fn_logger, paste0("Error: paralogs information unavailable for ", sp))
    } else {
        ls_paralogs <- readLines(fn_paralogs)
        ls_paralogs <- sapply(ls_paralogs, function(x) { unlist(strsplit(x, "-"))[2] })
        ls_busco <- ls_busco[!ls_busco%in%ls_paralogs]
    }

    fn_paralogs_depth <- paste0(outdir_sp, sp, "_genes_with_paralog_warnings_by_contig_depth.csv")
    if (!file.exists(fn_paralogs_depth) || file.size(fn_paralogs_depth)==0) {
        log4r::warn(fn_logger, paste0("Error: paralogs based on contig depth unavailable for ", sp))
    } else {
        ls_paralogs <- data.table::fread(fn_paralogs_depth)
        ls_paralogs <- ls_paralogs$V2[ls_paralogs$V4]
        ls_paralogs <- gsub("gene ", "", ls_paralogs)
        ls_busco <- ls_busco[!ls_busco%in%ls_paralogs]
    }

    # iterate over BUSCO
    foreach (busco = ls_busco) %dopar% {
        # output file
        fn_in_fa <- paste0(outdir_sp, busco, "/", sp, "/sequences/FNA/", busco, ".FNA")
        if (!file.exists(fn_in_fa)) {
            log4r::error(fn_logger, paste0("Error: ", busco, " for ", sp))
            return(NULL)
        }

        fn_out_fa <- paste0(params$outdir, "/", busco, "/", busco, ".fa")
        f_fasta2msa(fn_in_fa, sp, fn_out_fa)
    }
}

stopCluster(nwcl)

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over BUSCO
foreach(busco = ls_target_busco) %dopar% {
    # output directory
    dir_output_filtered <- paste0(params$outdir, "/", busco, "/post_mafft/")
    if (!dir.exists(dir_output_filtered)) {
        dir.create(dir_output_filtered, recursive=T)
    }

    # input and output files
    fn_in_fa <- paste0(params$outdir, "/", busco, "/", busco, ".fa")
    fn_x2gap_fa <- paste0(params$outdir, "/", busco, "/", busco, "_X2gap.fa")
    fn_rmSeq_fa <- paste0(params$outdir, "/", busco, "/", busco, "_rmSeq.fa")
    fn_mafft <- paste0(params$outdir, "/", busco, "/", busco, "_aligned.fa")

    prefix_cialign <- paste0(dir_output_filtered, busco, "_cialign")
    fn_cialign <- paste0(dir_output_filtered, busco, "_cialign_cleaned.fasta")
    fn_out_fa <- paste0(dir_output_filtered, busco, "_final.fa")
    
    # filter the alignments
    f_x2gap(fn_in_fa, fn_x2gap_fa)
    f_remove_seq(fn_x2gap_fa, fn_rmSeq_fa, 0.5)
    f_mafft(fn_rmSeq_fa, fn_mafft, "--retree 2", params$exe_mafft)
    f_cialign(fn_mafft, prefix_cialign, params$exe_cialign)
    f_remove_seq(fn_cialign, fn_out_fa, 0.5)
}

stopCluster(nwcl)
```

```{r trees}
# extract list of BUSCO
ls_busco <- list.dirs(params$outdir, recursive=F, full.names=F)
ls_busco <- ls_busco[ls_busco!="quibl"]

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over BUSCO
foreach(busco = ls_busco) %dopar% {
    # generate tree
    fn_in_fa <- paste0(params$outdir, "/", busco, "/post_mafft/", busco, "_final.fa")
    f_iqtree2(fn_in_fa, params$exe_iqtree2)
}

stopCluster(nwcl)

# output files
fn_all_treefile <- paste0(params$outdir, "/all.treefile")
fn_astral <- paste0(params$outdir, "/astral.treefile")
fn_astral_log <- paste0(params$outdir, "/astral.log")

# combine all treefiles
cmd <- paste0("cat ", params$outdir, "/*/*_aligned.fa.treefile > ", fn_all_treefile)
system(cmd)

# run ASTRAL
f_astral(fn_all_treefile, fn_astral, fn_astral_log, params$exe_astral)
```

```{r quibl}
# read alltree
alltrees <- ape::read.tree(fn_all_treefile)
sptree <- ape::read.tree(fn_astral)
sptree_distance <- ape::cophenetic.phylo(sptree)

# output directory
dir_output_quibl <- paste0(params$outdir, "/quibl/")

# read QuIBL metadata
df_quibl_metadata <- data.table::fread(params$fn_quibl_metadata)

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over quartet
df_output_quibl <- foreach (i = 1:nrow(df_quibl_metadata), .combine='rbind') %dopar% {
    require(ggplot2)

    # output directory
    temp_outdir_quibl <- paste0(dir_output_quibl, df_quibl_metadata$species_two[i], "/")
    if (!dir.exists(temp_outdir_quibl)) {
        dir.create(temp_outdir_quibl, recursive=T)
    }

    # extract taxa
    ls_quartet <- unlist(df_quibl_metadata[i,1:4])
    ls_subset_tre <- lapply(alltrees, function(x) {
        if (all(ls_quartet %in% x$tip.label)) {
            tr <- ape::keep.tip(x, tip=ls_quartet)
            tr <- ape::root(tr, outgroup=df_quibl_metadata$outgroup[i])
            return(tr)
        } else {
            return(NULL)
        }
    })

    # remove NULL
    ls_subset_tre <- ls_subset_tre[lengths(ls_subset_tre) != 0]

    # convert branch lengths
    ls_subset_tre_transformed <- lapply(ls_subset_tre, function(x) {
        tre_transformed <- ape::chronos(x)
        return(tre_transformed)
    })

    # save trees
    ape::write.tree(ls_subset_tre, file=paste0(temp_outdir_quibl, "all.tre"))
    ape::write.tree(ls_subset_tre_transformed, file=paste0(temp_outdir_quibl, "all_transformed.tre"))

    # extract distances
    ls_dist <- lapply(ls_subset_tre, function(x) {
        dist <- ape::cophenetic.phylo(x)
        dist <- dist[rownames(dist)==df_quibl_metadata$species_one[i], colnames(dist)==df_quibl_metadata$species_two[i]]
        return(dist)
    })
    ls_dist <- unlist(ls_dist)
    write.table(ls_dist, file=paste0(temp_outdir_quibl, "all_dist.txt"), quote=F, row.names=F, col.names=F)

    ls_dist_transformed <- lapply(ls_subset_tre_transformed, function(x) {
        dist <- ape::cophenetic.phylo(x)
        dist <- dist[rownames(dist)==df_quibl_metadata$species_one[i], colnames(dist)==df_quibl_metadata$species_two[i]]
        return(dist)
    })
    ls_dist_transformed <- unlist(ls_dist_transformed)
    write.table(ls_dist_transformed, file=paste0(temp_outdir_quibl, "all_transformed_dist.txt"), quote=F, row.names=F, col.names=F)

    # visualisation
    plot <- ggplot() +
        geom_density(aes(x=ls_dist), colour="blue") +
        geom_density(aes(x=ls_dist_transformed), colour="red")

    tiff(filename=paste0(temp_outdir_quibl, "dist.tiff"))
    print(plot)
    dev.off()

    # run QuIBL
    write.table(c("[Input]",
                  paste0("treefile: ", temp_outdir_quibl, "all.tre"),
                  "numdistributions: 2",
                  "likelihoodthresh: 0.01",
                  "numsteps: 10",
                  "gradascentscalar: 0.5",
                  paste0("totaloutgroup: ", df_quibl_metadata$outgroup[i]),
                  "multiproc: True",
                  "maxcores:1000",
                  "",
                  "[Output]",
                  paste0("OutputPath: ", temp_outdir_quibl, "quibl.csv")),
                file=paste0(temp_outdir_quibl, "quibl.txt"), quote=F, row.names=F, col.names=F)
    f_quibl(paste0(temp_outdir_quibl, "quibl.txt"), params$exe_quibl)

    write.table(c("[Input]",
                  paste0("treefile: ", temp_outdir_quibl, "all_transformed.tre"),
                  "numdistributions: 2",
                  "likelihoodthresh: 0.01",
                  "numsteps: 10",
                  "gradascentscalar: 0.5",
                  paste0("totaloutgroup: ", df_quibl_metadata$outgroup[i]),
                  "multiproc: True",
                  "maxcores:1000",
                  "",
                  "[Output]",
                  paste0("OutputPath: ", temp_outdir_quibl, "quibl_transformed.csv")),
                file=paste0(temp_outdir_quibl, "quibl_transformed.txt"), quote=F, row.names=F, col.names=F)
    f_quibl(paste0(temp_outdir_quibl, "quibl_transformed.txt"), params$exe_quibl)

    # extract QuIBL results
    quibl_mixprop2 <- NA
    quibl_count <- NA
    quibl_transformed_mixprop2 <- NA
    quibl_transformed_count <- NA

    if (file.exists(paste0(temp_outdir_quibl, "quibl.csv"))) {
        df_quibl <- data.table::fread(paste0(temp_outdir_quibl, "quibl.csv"))

        quibl_mixprop2 <- df_quibl$mixprop2[df_quibl$outgroup==df_quibl_metadata$species_three[i]]
        quibl_count <- df_quibl$count[df_quibl$outgroup==df_quibl_metadata$species_three[i]]
    }

    if (file.exists(paste0(temp_outdir_quibl, "quibl_transformed.csv"))) {
        df_quibl_transformed <- data.table::fread(paste0(temp_outdir_quibl, "quibl_transformed.csv"))

        quibl_transformed_mixprop2 <- df_quibl_transformed$mixprop2[df_quibl_transformed$outgroup==df_quibl_metadata$species_three[i]]
        quibl_transformed_count <- df_quibl_transformed$count[df_quibl_transformed$outgroup==df_quibl_metadata$species_three[i]]
    }

    return(data.table::data.table(species_one=df_quibl_metadata$species_one[i],
                                  species_two=df_quibl_metadata$species_two[i],
                                  quibl_mixprop2=quibl_mixprop2,
                                  quibl_count=quibl_count,
                                  quibl_transformed_mixprop2=quibl_transformed_mixprop2,
                                  quibl_transformed_count=quibl_transformed_count,
                                  f1_hybrid=df_quibl_metadata$percentage_hybrid[i],
                                  astral_pairwise_dist=sptree_distance[rownames(sptree_distance)==df_quibl_metadata$species_one[i],
                                                                       colnames(sptree_distance)==df_quibl_metadata$species_two[i]]
    ))
}

stopCluster(nwcl)

# save data.table
data.table::fwrite(df_output_quibl, file=paste0(dir_output_quibl, "quibl.tsv"), sep="\t", quote=F)
```