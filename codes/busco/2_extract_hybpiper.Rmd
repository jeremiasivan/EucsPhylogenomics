---
title: "Extract BUSCO from HybPiper"
author: "Jeremias Ivan"
date: "`r format(Sys.time(), '%d %B %Y, %H:%M%p')`"

output:
  html_document:
    code_folding: show
    toc: true
    toc_float: true

params:
  # general
  codedir: "~/EucsPhylogenomics/codes/busco"
  outdir: "~/simulation"
  thread: 10
  redo: FALSE

  # input directory
  fn_target_dna: ""
  dir_hybpiper_output: ""

  focal_species: "E_globulus_Maidenaria_Symphyomyrtus-REF"
  fn_target_species: "~/EucsPhylogenomics/files/target_species.txt"

  # executable
  exe_mafft: ""
  exe_iqtree2: ""
  exe_astral: ""
---

## Load required libraries and functions
```{r}
source(paste0(params$codedir, "/functions.R"))

library(data.table)
library(doSNOW)
library(tidyverse)
```

```{r, include=FALSE}
# install.packages("ape")
# install.packages("Biostrings")
# install.packages("log4r")

# store initial system time
sys_tic <- Sys.time()

# create outdir
currentdir <- paste0(params$outdir, "/")
if (!dir.exists(currentdir)) {
  dir.create(currentdir, recursive = T)
}

# create log file
fn_log <- paste0(params$outdir, "/extract_hybpiper.log")
log_appender <- log4r::file_appender(fn_log, append = TRUE, layout = log4r::default_log_layout())
fn_logger <- log4r::logger(threshold = "INFO", appenders = log_appender)
if (params$redo || !file.exists(fn_log)) {
  unlink(fn_log)
  write.table(c("EucsPhylogenomics",
                "Developed by Jeremias Ivan"),
              file=fn_log, quote=F, row.names=F, col.names=F)
}

knitr::opts_knit$set(root.dir = currentdir)
```

```{r references}
# open target DNA
seq <- Biostrings::readDNAStringSet(params$fn_target_dna)
names(seq) <- gsub(" ", "", names(seq))

ls_target_busco <- names(seq)
ls_target_busco <- unique(sapply(ls_target_busco, function(x) { unlist(strsplit(x, "-"))[2] }))

log4r::info(fn_logger, paste0("Number of BUSCO: ", length(ls_target_busco)))

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over BUSCO
foreach(busco = ls_target_busco) %dopar% {
    # output directory
    output_busco <- paste0(params$outdir, "/", busco, "/")
    if (!dir.exists(output_busco)) {
        dir.create(output_busco, recursive=T)
    }

    # extract BUSCO headers
    idx <- grepl(paste0("-", busco, "$"), names(seq))
    busco_seq <- seq[idx]

    # update BUSCO headers
    names(busco_seq) <- sapply(names(busco_seq), function(x) {
        header <- gsub("_N/A", "", x)
    })

    # output file
    fn_out_fa <- paste0(output_busco, busco, ".fa")
    Biostrings::writeXStringSet(busco_seq, filepath=fn_out_fa)
}

stopCluster(nwcl)
```

```{r alignments}
# extract list of species
ls_species <- list.dirs(params$dir_hybpiper_output, recursive=F, full.names=F)

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over species
for (sp in ls_species) {
    # HybPiper output directory
    outdir_sp <- paste0(params$dir_hybpiper_output, "/", sp, "/")

    # extract list of BUSCO
    ls_busco <- list.dirs(outdir_sp, recursive=F, full.names=F)

    # read file containing paralogs
    fn_paralogs <- paste0(outdir_sp, sp, "_genes_with_long_paralog_warnings.txt")
    if (!file.exists(fn_paralogs)) {
        log4r::warn(fn_logger, paste0("Error: paralogs information unavailable for ", sp))
    } else {
        ls_paralogs <- readLines(fn_paralogs)
        ls_paralogs <- sapply(ls_paralogs, function(x) { unlist(strsplit(x, "-"))[2] })
        ls_busco <- ls_busco[!ls_busco%in%ls_paralogs]
    }

    # iterate over BUSCO
    foreach (busco = ls_busco) %dopar% {
        # output file
        fn_in_fa <- paste0(outdir_sp, busco, "/", sp, "/sequences/FNA/", busco, ".FNA")
        if (!file.exists(fn_in_fa)) {
            log4r::error(fn_logger, paste0("Error: ", busco, " for ", sp))
            return(NULL)
        }

        fn_out_fa <- paste0(params$outdir, "/", busco, "/", busco, ".fa")
        f_fasta2msa(fn_in_fa, sp, fn_out_fa)
    }
}

stopCluster(nwcl)
```

```{r trees}
# extract list of BUSCO
ls_busco <- list.dirs(params$outdir, recursive=F, full.names=F)

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

# iterate over BUSCO
foreach(busco = ls_busco) %dopar% {
    # input and output files
    fn_in_fa <- paste0(params$outdir, "/", busco, "/", busco, ".fa")
    fn_out_fa <- paste0(params$outdir, "/", busco, "/", busco, "_aligned.fa")
    
    # run MAFFT
    f_mafft(fn_in_fa, fn_out_fa, "--retree 2", params$exe_mafft)
    f_iqtree2(fn_out_fa, params$exe_iqtree2)
}

stopCluster(nwcl)

# output files
fn_all_treefile <- paste0(params$outdir, "/all.treefile")
fn_astral <- paste0(params$outdir, "/astral.treefile")
fn_astral_log <- paste0(params$outdir, "/astral.log")

# combine all treefiles
cmd <- paste0("cat ", params$outdir, "/*/*_aligned.fa.treefile > ", fn_all_treefile)
system(cmd)

# run ASTRAL
f_astral(fn_all_treefile, fn_astral, fn_astral_log, params$exe_astral)
```

```{r phylodistance}
# extract list of BUSCO
ls_busco <- list.dirs(params$outdir, recursive=F, full.names=F)

# read input file
ls_target_species <- NULL
if (!is.null(params$fn_target_species) && file.exists(params$fn_target_species)) {
    ls_target_species <- readLines(params$fn_target_species)
}

# create doSNOW clusters
nwcl <- makeCluster(params$thread)
registerDoSNOW(nwcl)

if (!is.null(ls_target_species)) {
    # iterate over BUSCO
    df_output <- foreach(busco = ls_busco, .combine='rbind') %dopar% {
        # input files
        fn_treefile <- paste0(params$outdir, "/", busco, "/", busco, "_aligned.fa.treefile")

        # open treefile
        tre <- ape::read.tree(fn_treefile)
        dist <- ape::cophenetic.phylo(tre)
        
        # output data.table
        df_output_temp <- data.table::data.table(busco=character(), species_one=character(), species_two=character(), distance=numeric())

        # iterate over target species
        for (sp in ls_target_species) {
            # extract distance
            dist <- NA
            if (params$focal_species%in%rownames(dist) && sp%in%colnames(dist)) {
                dist <- dist[rownames(dist)==params$focal_species, colnames(dist)==sp]
            }

            df_output_temp <- rbind(df_output_temp, data.table::data.table(busco=busco,
                                                                           species_one=params$focal_species,
                                                                           species_two=sp,
                                                                           distance=dist))
        }

        return(df_output_temp)
    }

    # save the data.table
    data.table::fwrite(df_output, file=paste0(params$outdir, "/dist_summary.tsv", quote=F, sep="\t"))
}

stopCluster(nwcl)
```

``````{r phylomrca}
# output data.table
df_count <- data.table::data.table(species_one=character(), species_two=character(), n=numeric())

# open all treefiles
alltre <- ape::read.tree(fn_all_treefile)

if (!is.null(ls_target_species)) {
    # iterate over target species
    for (sp in ls_target_species) {
        sister_count <- sum(sapply(alltre, function(tre) {
            # get the MRCA
            mrca_node <- getMRCA(tre, c(params$focal_species, sp))

            # check if the two species are sister species
            if (!is.null(mrca_node)) {
                descendants <- extract.clade(tre, mrca_node)$tip.label
                setequal(descendants, c(params$focal_species, sp))
            } else {
                return(FALSE)
            }
        }))

        # update data.frame
        df_count <- rbind(df_count, data.table::data.table(species_one=params$focal_species,
                                                           species_two=sp,
                                                           n=sister_count))
    }

} else {
    # update naming convention
    alltre_updated <- lapply(alltre, function(tr) {
        tr$tip.label <- sapply(tr$tip.label, function(header) {
            new <- unlist(strsplit(header, split="-"))
            if (length(new)>1) {
                new <- paste0(new[1], "-REF")
            }

            return(new)
        })

        return(ape::as.phylo(tr))
    })

    # extract sister taxa
    sister_list <- lapply(alltre_updated, f_get_sister_taxa, focal_sp=params$focal_species)
    sister_list <- sister_list[!sapply(sister_list, is.na)]

    # extract frequency
    sister_list <- sapply(sister_list, function(x) {
        if (!all(is.na(x))) {
            paste(sort(x), collapse = "_")
        }
    })

    # extract closest taxa
    closest_list <- lapply(alltre_updated, f_get_closest_taxa, focal_sp=params$focal_species)
    closest_list <- unlist(closest_list[!is.na(closest_list)])

    # count the frequency
    df_count_sister <- as.data.frame(table(sister_list))
    df_count_closest <- as.data.frame(table(closest_list))

    colnames(df_count_sister) <- c("species_two", "n")
    colnames(df_count_closest) <- c("species_two", "n")
    df_count <- merge(df_count_sister, df_count_closest, by="species_two", all=TRUE)
    colnames(df_count) <- c("species_two", "sister_taxon", "closest_taxon")

    df_count <- df_count %>% mutate(species_one=params$focal_species, .before=species_two) %>%
                    mutate(sister_taxon = if_else(is.na(sister_taxon), 0, sister_taxon),
                           closest_taxon = if_else(is.na(closest_taxon), 0, closest_taxon)) %>%
                    arrange(desc(sister_taxon))
}

# save the data.table
data.table::fwrite(df_count, file=paste0(params$outdir, "/count_summary.tsv", quote=F, sep="\t"))
```